using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CNN1
{
    class NN
    {
        int Depth = 3;
        string layers { get; set; }
        List<Layer> Layers { get; set; }
        public void Run()
        {       

        }
    }
    public class Neuron
    {
        public double[,] Weights { get; set; }
        public double[,] WeightMomentum { get; set; }
        public double[,] WeightGradient { get; set; }
        public double Bias { get; set; }
        public double BiasMomentum { get; set; }
        public double BiasGradient { get; set; }
        public double Value { get; set; }
        public double ZVal { get; set; }
        public double Error { get; set; }
    }
    public class Kernel
    {
        public double[,] kernel { get; set; }
        public double[,] error { get; set; }
        public double[,] gradient { get; set; }
    }
    class ActivationFunctions
    {
        public static double Tanh(double number)
        {
            return (Math.Pow(Math.E, 2 * number) - 1) / (Math.Pow(Math.E, 2 * number) + 1);
        }
        public static double TanhDerriv(double number)
        {
            return (1 - Math.Pow(Tanh(number), 2));
        }
    }
    class Layer
    {
        double AvgGradient { get; set; }
        string  Type { get; set; }
        public Kernel lKernel { get; set; }
        List<Neuron> Neurons { get; set; }
        public void Forward(double[,] image, int poolsize, int stride)
        {
            List<double> input = new List<double>();
            foreach (double d in image) { input.Add(d); }
            switch (Type)
            {
                case "input":
                    Calculate(input); break;
                case "pool":
                    Pool(image, poolsize); break;
                case "convolve":
                    Convolve(image, stride); break;
                case "hidden":
                    Calculate(input); break;
                case "output":
                    Calculate(input); break;
                default: throw new Exception("Invalid layer type: \"" + Type + "\"");
            }
        }
        public void Backward(Layer output, int correct)
        {
            switch (Type)
            {
                case "input":
                    Backprop(output); break;
                case "pool":
                    break;
                case "convolve":
                    break;
                case "hidden":
                    Backprop(output); break;
                case "output":
                    Backprop(correct); break;
                default: throw new Exception("Invalid layer type: \"" + Type + "\"");
            }
        }
        void KernelDescend()
        {

        }
        void Descend(int batchsize)
        {
            foreach (Neuron n in Neurons)
            {
                for (int i = 0; i < n.Weights.Count; i++)
                {
                    double gradient = n.WeightGradient[i] * (-2d / batchsize);
                    n.Weights[i] -= gradient;
                    AvgGradient -= gradient;
                }
            }
            AvgGradient /= Neurons.Count;
        }
        void Descend(Layer input, double momentum, double learningrate)
        {
            foreach (Neuron n in Neurons)
            {
                //Foreach weight in n.weights
                for (int i = 0; i < n.Weights.Count; i++)
                {
                    foreach (Neuron n2 in input.Neurons)
                    {
                        //Weight gradients
                        double wgradient = learningrate * n2.Value * ActivationFunctions.TanhDerriv(n.ZVal) * n.Error;
                        n.WeightMomentum[i] = (n.WeightMomentum[i] * momentum) - (learningrate * wgradient);
                        n.WeightGradient[i] += wgradient + n.WeightMomentum[i];
                    }
                }
                //Bias gradients
                double bgradient = learningrate * ActivationFunctions.TanhDerriv(n.ZVal) * n.Error;
                n.BiasMomentum = (n.BiasMomentum * momentum) - (learningrate * bgradient);
                n.BiasGradient += bgradient + n.BiasMomentum;
            }
        }
        void Backprop(Layer output, int poolsize)
        {
            if (output.Type == "pool")
            {

            }
            if (Type == "convolve")
            {
                foreach (Neuron n in output.Neurons)
                {
                    for (int i = 0; i < lKernel.kernel.GetLength(0); i++)
                    {
                        for (int ii = 0; ii < lKernel.kernel.GetLength(1); ii++)
                        {
                            lKernel.error[i, ii] += n.Weights[(i * lKernel.kernel.GetLength(0)) + ii] 
                                * ActivationFunctions.TanhDerriv(n.ZVal) * n.Error;
                        }
                    }
                }
                return;
            }
            if (output.Type == "convolve")
            {
                //Convolution as output is not defined as of yet
                // (it does not take in a list, only an array right now)
                return;
            }
            foreach (Neuron n in output.Neurons)
            {
                for (int i = 0; i < Neurons.Count; i++)
                {
                    Neurons[i].Error += n.Weights[i] * ActivationFunctions.TanhDerriv(n.ZVal) * n.Error;
                }
            }
        }
        void Backprop(int correct)
        {
            for (int i = 0; i < Neurons.Count; i++)
            {
                Neurons[i].Error = 2d * ((i == correct ? 1d : 0d) - Neurons[i].Value);
            }
        }
        void Calculate(List<double> input)
        {
            foreach (Neuron n in Neurons)
            {
                for (int i = 0; i < input.Count; i++)
                {
                    n.ZVal += ((n.Weights[i] + n.WeightMomentum[i]) * input[i]) + n.Bias + n.BiasMomentum;
                }
                n.Value = ActivationFunctions.Tanh(n.ZVal);
            }
        }
        public double[,] Convolve(double[,] input, int strideLength)
        {
            int kernelSize = lKernel.kernel.GetLength(0);
            if (input.GetLength(0) % kernelSize != 0 || input.GetLength(1) % kernelSize != 0)
            { throw new Exception("Kernel does not divide cleanly"); }
            //Need to implement dynamic kernel size in the future
            int lengthOffset = 0;
            int widthOffset = 0;
            List<double> sums = new List<double>();

            //Convolve the image from kernal
            while (input.GetLength(1) - widthOffset >= 0)
            {
                lengthOffset = 0;
                while (input.GetLength(0) - lengthOffset >= 0)
                {
                    double sum = 0;
                    for (int i = 0; i < kernelSize; i++)
                    {
                        for (int ii = 0; ii < kernelSize; ii++)
                        {
                            //Kernel is flipped
                            sum += lKernel.kernel[kernelSize - i, kernelSize - ii] * input[lengthOffset + i, widthOffset + ii];
                        }
                    }
                    sums.Add(sum);
                    lengthOffset += strideLength;
                }
                widthOffset += strideLength;
            }

            //Write to a new matrix
            int sqrt = (int)Math.Sqrt(sums.Count);
            double[,] thing = new double[sqrt, sqrt];
            for (int i = 0; i < sqrt; i++)
            {
                for (int ii = 0; ii < sqrt; ii++)
                {
                    thing[i, ii] = sums[(i * sqrt) + ii];
                }
            }

            return thing;
        }
        double[,] Pool(double[,] input, int poolSize)
        {
            int length = input.GetLength(0) / poolSize;
            int width = input.GetLength(1) / poolSize;
            double[,] output = new double[length, width];
            for (int i = 0; i < input.GetLength(0); i++)
            {
                for (int ii = 0; ii < input.GetLength(1); ii ++)
                {
                    double value = input[i, ii];
                    if (output[i / poolSize, ii / poolSize] < value)
                    { output[i / poolSize, ii / poolSize] = value; }
                }
            }
            return output;
        }
    }
}
